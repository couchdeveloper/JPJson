<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="html/html; charset=utf-8" />
		<title>JPAsyncJsonParser Class Reference</title>
		<meta id="xcode-display" name="xcode-display" content="render"/>
		<meta name="viewport" content="width=550" />
		<link rel="stylesheet" type="text/css" href="../css/styles.css" media="all" />
		<link rel="stylesheet" type="text/css" media="print" href="../css/stylesPrint.css" />
		<meta name="generator" content="appledoc 2.0.5 (build 789)" />
	</head>
	<body>
		<header id="top_header">
			<div id="library" class="hideInXcode">
				<h1><a id="libraryTitle" href="../index.html">JPJson </a></h1>
				<a id="developerHome" href="../index.html">Bit Passion</a>
			</div>
			
			<div id="title" role="banner">
				<h1 class="hideInXcode">JPAsyncJsonParser Class Reference</h1>
			</div>
			<ul id="headerButtons" role="toolbar">
				<li id="toc_button">
					<button aria-label="Show Table of Contents" role="checkbox" class="open" id="table_of_contents"><span class="disclosure"></span>Table of Contents</button>
				</li>
				<li id="jumpto_button" role="navigation">
					<select id="jumpTo">
	<option value="top">Jump To&#133;</option>
	
	<option value="overview">Overview</option>
	
	
	
	
	<option value="tasks">Tasks</option>
	
	
	
	
	
	<option value="properties">Properties</option>
	
	<option value="//api/name/semanticActions">&nbsp;&nbsp;&nbsp;&nbsp;semanticActions</option>
	
	
	
	
	
	
	<option value="instance_methods">Instance Methods</option>
	
	<option value="//api/name/cancel">&nbsp;&nbsp;&nbsp;&nbsp;- cancel</option>
	
	<option value="//api/name/init">&nbsp;&nbsp;&nbsp;&nbsp;- init</option>
	
	<option value="//api/name/initWithSemanticActions:workerDispatchQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithSemanticActions:workerDispatchQueue:</option>
	
	<option value="//api/name/isRunning">&nbsp;&nbsp;&nbsp;&nbsp;- isRunning</option>
	
	<option value="//api/name/parseBuffer:">&nbsp;&nbsp;&nbsp;&nbsp;- parseBuffer:</option>
	
	<option value="//api/name/start">&nbsp;&nbsp;&nbsp;&nbsp;- start</option>
	
	
	
</select>
				</li>
			</ul>
		</header>
		<nav id="tocContainer" class="isShowingTOC">
			<ul id="toc" role="tree">
				
<li role="treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#overview">Overview</a></span></li>




<li role="treeitem" id="task_treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#tasks">Tasks</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Initialization">Initialization</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Properties">Properties</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Starting the Parser Asynchronously">Starting the Parser Asynchronously</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Providing Data Buffers">Providing Data Buffers</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Canceling an Asynchronously Running Parser">Canceling an Asynchronously Running Parser</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Check if a Parser is Running">Check if a Parser is Running</a></span></li>
	
</ul></li>





<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#properties">Properties</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/semanticActions">semanticActions</a></span></li>
	
</ul></li>





<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#instance_methods">Instance Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/cancel">cancel</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/init">init</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithSemanticActions:workerDispatchQueue:">initWithSemanticActions:workerDispatchQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isRunning">isRunning</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/parseBuffer:">parseBuffer:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/start">start</a></span></li>
	
</ul></li>


			</ul>
		</nav>
		<article>
			<div id="contents" class="isShowingTOC" role="main">
				<a title="JPAsyncJsonParser Class Reference" name="top"></a>
				<div class="main-navigation navigation-top">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="header">
					<div class="section-header">
						<h1 class="title title-header">JPAsyncJsonParser Class Reference</h1>
					</div>		
				</div>
				<div id="container">	
					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<td class="specification-title">Inherits from</td>
	<td class="specification-value">NSObject</td>
</tr><tr>
	<td class="specification-title">Declared in</td>
	<td class="specification-value">JPAsyncJsonParser.h<br />JPAsyncJsonParser.mm</td>
</tr>
						</tbody></table></div>
					
					
					
					
					<div class="section section-overview">
						<a title="Overview" name="overview"></a>
						<h2 class="subtitle subtitle-overview">Overview</h2>
						<p>While a <code>JPJsonParser</code> can only parse input which contains one or more JSON
documents that is provided in <em>one</em> buffer which is a contiguous sequence of
bytes in memory, a <code>JPAsyncJsonParser</code> is capable to parse input which is
partitioned into a contiguous set of data buffers. The concatenated content may
comprise one or more JSON documents.</p>

<p>When downloading a resource from the net, the underlaying network layer will
usually provide the content in chunks, each contained in a data buffer. For example,
<code>NSURLConnection</code> delivers the content as a sequence of <code>NSData</code> objects to its delegate.
The sequence of data buffers make up the complete input which may contain one or more
JSON documents.</p>

<p><code>JPAsyncJsonParser</code> provides an interface where a sequence of <code>NSData</code> buffers can
be sent via the message <code>parseBuffer:</code> to a <code>JPAsyncJsonParser</code> object. This makes
<code>JPAsyncJsonParser</code> especially suited to receive partial input which will be
received as a sequence of data buffers, e.g. from a <code>NSURLConnection</code> delegate or
through a <code>NSStream</code> interface.</p>

<p>A <code>JPAsyncJsonParser</code> instance will invoke the underlaying parser
asynchronously. That is, when an <code>JPAsyncJsonParser</code> instance receives the
<code>start</code> message, the underlaying JSON parser will be executed on a different
thread and the method <code>start</code> returns  immediately. The underlaying JSON parser
will then wait for incoming data buffer to become available for parsing.</p>

<p>The client is responsible to provide the sequence of <code>NSData</code> objects which
will be sent by message <code>parserBuffer:</code> to the <code>JPAsyncJsonParser</code> instance.
The underlaying JSON parser in turn will consume this data buffer and start
parsing it. As a result it will send parse events to the semantic actions
object as long as there is data available, or until the parser receives an
<code>EOF</code> from the input. If there is no data available and the parser expects
yet more input, the parser&rsquo;s thread will be blocked until data is available
again.</p>

<p>A client of an asynchronous parser will be notified about the result of a
semantic actions object and other events through the means of <em>handler blocks</em>
which will be assigned the semantic actions object via properties. The exact
behavior depends on the concrete semantic actions class. For more information
on semantic actions see <a href="../Protocols/JPSemanticActionsProtocol.html">JPSemanticActionsProtocol</a>, <a href="../Classes/JPSemanticActionsBase.html">JPSemanticActionsBase</a>,
<a href="../Classes/JPRepresentationGenerator.html">JPRepresentationGenerator</a> and <a href="../Classes/JPStreamSemanticActions.html">JPStreamSemanticActions</a>.</p>

<p>A <code>JPAsyncJsonParser</code> object can only be used once for parsing the input. That is,
once the message <code>start</code> has been sent, it cannot be invoked again. In order to
parse another input, a new parser object must be created. The input can consist
of many JSON documents however, and the total length of the input stream can be
virtually infinitive.</p>
					</div>
					
					
					
					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						<h2 class="subtitle subtitle-tasks">Tasks</h2>
						
						
						<a title="Initialization" name="task_Initialization"></a>
						<h3 class="subsubtitle task-title">Initialization</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithSemanticActions:workerDispatchQueue:">&ndash;&nbsp;initWithSemanticActions:workerDispatchQueue:</a></code>
		<span class="tooltip"><p><em>Designated Initializer</em></p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/init">&ndash;&nbsp;init</a></code>
		<span class="tooltip"><p>Invokes the designated initializer with parameter <code>semanticActions</code> set to <code>nil</code>
and <code>workerQueue</code> set to <code>NULL</code>.</p></span>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Properties" name="task_Properties"></a>
						<h3 class="subsubtitle task-title">Properties</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/semanticActions">&nbsp;&nbsp;semanticActions</a></code>
		<span class="tooltip"><p>Returns the semantic actions object.</p></span>
	</span>
	<span class="task-item-suffix">property</span>
	
</li>
						</ul>
						
						
						<a title="Starting the Parser Asynchronously" name="task_Starting the Parser Asynchronously"></a>
						<h3 class="subsubtitle task-title">Starting the Parser Asynchronously</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/start">&ndash;&nbsp;start</a></code>
		<span class="tooltip"><p>Start the parser asynchronously. The parser will wait for data buffers to
become available provided by method parseBuffer:. Once the first buffer is
available, the parser will try to determine the encoding of the input. If
any error occurs while detecting the encoding, the parser will issue an
error which will cause the error handler to be called (if it is not <code>NULL</code>).
Otherwise, the parser will continue to parse the input from the buffers,
until no more buffers are available.</p></span>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Providing Data Buffers" name="task_Providing Data Buffers"></a>
						<h3 class="subsubtitle task-title">Providing Data Buffers</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/parseBuffer:">&ndash;&nbsp;parseBuffer:</a></code>
		<span class="tooltip"><p>Push a data buffer to the parser&rsquo;s internal buffer queue which the parser
will start to process when it becomes ready.</p></span>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Canceling an Asynchronously Running Parser" name="task_Canceling an Asynchronously Running Parser"></a>
						<h3 class="subsubtitle task-title">Canceling an Asynchronously Running Parser</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/cancel">&ndash;&nbsp;cancel</a></code>
		<span class="tooltip"><p>Synchronously cancels the parser which forces it to exit as soon as possible.
After returning from cancel, it is guaranteed that no blocks will be invoked
and no delegate will receive any messages. <code>cancel</code> will block until the parser&rsquo;s
worker thread has been exited.
After canceling the parser&rsquo;s result and error state is undefined.</p></span>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Check if a Parser is Running" name="task_Check if a Parser is Running"></a>
						<h3 class="subsubtitle task-title">Check if a Parser is Running</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/isRunning">&ndash;&nbsp;isRunning</a></code>
		<span class="tooltip"><p>Returns <code>YES</code> if the parser has been started and is currently running.</p></span>
	</span>
	
	
</li>
						</ul>
						
					</div>
					
					
					
					
					
					<div class="section section-methods">
						<a title="Properties" name="properties"></a>
						<h2 class="subtitle subtitle-methods">Properties</h2>
						
						<div class="section-method">
	<a name="//api/name/semanticActions" title="semanticActions"></a>
	<h3 class="subsubtitle method-title">semanticActions</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns the semantic actions object.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>@property (nonatomic, readonly, strong) JPSemanticActionsBase *semanticActions</code></div>
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">JPAsyncJsonParser.h</code><br />
	</div>				
	
	
</div>
						
					</div>
					
					
					
					
					
					<div class="section section-methods">
						<a title="Instance Methods" name="instance_methods"></a>
						<h2 class="subtitle subtitle-methods">Instance Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/cancel" title="cancel"></a>
	<h3 class="subsubtitle method-title">cancel</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Synchronously cancels the parser which forces it to exit as soon as possible.
After returning from cancel, it is guaranteed that no blocks will be invoked
and no delegate will receive any messages. <code>cancel</code> will block until the parser&rsquo;s
worker thread has been exited.
After canceling the parser&rsquo;s result and error state is undefined.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>- (void)cancel</code></div>
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">JPAsyncJsonParser.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/init" title="init"></a>
	<h3 class="subsubtitle method-title">init</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Invokes the designated initializer with parameter <code>semanticActions</code> set to <code>nil</code>
and <code>workerQueue</code> set to <code>NULL</code>.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>- (id)init</code></div>
	
	
	
	
	
	
	
	
	
	
	
	
	<div class="method-subsection see-also-section">
		<h4 class="method-subtitle">See Also</h4>
		<ul>
			
			<li><code><p><a href="#//api/name/initWithSemanticActions:workerDispatchQueue:">&ndash; initWithSemanticActions:workerDispatchQueue:</a></p></code></li>
			
		</ul>
	</div>
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">JPAsyncJsonParser.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithSemanticActions:workerDispatchQueue:" title="initWithSemanticActions:workerDispatchQueue:"></a>
	<h3 class="subsubtitle method-title">initWithSemanticActions:workerDispatchQueue:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p><em>Designated Initializer</em></p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>- (id)initWithSemanticActions:(JPSemanticActionsBase *)<em>semanticActions</em> workerDispatchQueue:(dispatch_queue_t)<em>workerQueue</em></code></div>
	
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>semanticActions</em></dt>
			<dd><p>A semantic actions object or <code>nil</code>.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>workerQueue</em></dt>
			<dd><p>A dispatch queue or <code>NULL</code>.</p></dd>
		</dl>
		
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>If object <em>semanticActions</em> equals <code>nil</code> an instance of class <code>JPRepresentationGenerator</code>
will be created and initialized with default properties. The default values
which will be set are documented in class <a href="../Classes/JPRepresentationGenerator.html">JPRepresentationGenerator</a>.</p>

<p>If parameter <em>workerQueue</em> equals <code>NULL</code> the parsing routines will be scheduled
on the global dispatch queue. This is usually a good choice.</p>

<p>The semantic actions handler dispatch queue and the parser&rsquo;s worker dispatch
queue must not be the same, unless the semantic actions object property
<code>parseMultipleDocumentsAsynchronously</code> equals <code>YES</code>.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">JPAsyncJsonParser.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isRunning" title="isRunning"></a>
	<h3 class="subsubtitle method-title">isRunning</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns <code>YES</code> if the parser has been started and is currently running.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>- (BOOL)isRunning</code></div>
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">JPAsyncJsonParser.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/parseBuffer:" title="parseBuffer:"></a>
	<h3 class="subsubtitle method-title">parseBuffer:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Push a data buffer to the parser&rsquo;s internal buffer queue which the parser
will start to process when it becomes ready.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>- (BOOL)parseBuffer:(NSData *)<em>buffer</em></code></div>
	
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>buffer</em></dt>
			<dd><p>A <code>NSData</code> object possibly containing a partial input.
If buffer equals <code>nil</code> the parser treats it as <code>EOF</code> and stops parsing.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>Returns <code>YES</code> if the parser will consume this buffer. Returns <code>NO</code> if a
timeout occurred, or if the parser is in cancel or error state.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>The content of <em>buffer</em> may contain partial JSON text in which case subsequent
invocations of <code>parseBuffer:</code> will be required in order to finish parsing of
one or more JSON texts.</p>

<p>The method will block until after the parser is ready to consume this buffer,
that is, when it has finished the previous buffer or when it is idle. It does
not block however for the time it takes to process this buffer.</p>

<p>buffer will be retained for the duration of use and then released again.</p><div class="warning"><p><strong>Warning:</strong> <em>Caution:</em> The buffer&rsquo;s byte sequence MUST start or end only at
complete Unicode <em>code unites</em>. That is, for instance, UTF-8 encoded text may
start and end at any byte boundary, while UTF-16 and UTF-32 requires to start
and end at their respective code units (two bytes and four bytes).</p></div>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">JPAsyncJsonParser.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/start" title="start"></a>
	<h3 class="subsubtitle method-title">start</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Start the parser asynchronously. The parser will wait for data buffers to
become available provided by method parseBuffer:. Once the first buffer is
available, the parser will try to determine the encoding of the input. If
any error occurs while detecting the encoding, the parser will issue an
error which will cause the error handler to be called (if it is not <code>NULL</code>).
Otherwise, the parser will continue to parse the input from the buffers,
until no more buffers are available.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>- (BOOL)start</code></div>
	
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>Returns <code>YES</code> if the parser has not yet been started previously.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Depending on the actual semantic actions object, their handlers may be
called whenever the start of a JSON document was found in the input stream
and whenever a JSON document has been created. Finally, if the end of the
data is detected a completion handler may be called.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">JPAsyncJsonParser.h</code><br />
	</div>				
	
	
</div>
						
					</div>
					
					
				</div>
				<div class="main-navigation navigation-bottom">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="footer">
					<hr />
					<div class="footer-copyright">
						<p><span class="copyright">&copy; 2013 Bit Passion. All rights reserved. (Last updated: 2013-04-14)</span><br />
						
						<span class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.0.5 (build 789)</a>.</span></p>
						
					</div>
				</div>
			</div>
		</article>
		<script type="text/javascript">
			function jumpToChange()
			{
				window.location.hash = this.options[this.selectedIndex].value;
			}
			
			function toggleTOC()
			{
				var contents = document.getElementById('contents');
				var tocContainer = document.getElementById('tocContainer');
				
				if (this.getAttribute('class') == 'open')
				{
					this.setAttribute('class', '');
					contents.setAttribute('class', '');
					tocContainer.setAttribute('class', '');
					
					window.name = "hideTOC";
				}
				else
				{
					this.setAttribute('class', 'open');
					contents.setAttribute('class', 'isShowingTOC');
					tocContainer.setAttribute('class', 'isShowingTOC');
					
					window.name = "";
				}
				return false;
			}
			
			function toggleTOCEntryChildren(e)
			{
				e.stopPropagation();
				var currentClass = this.getAttribute('class');
				if (currentClass == 'children') {
					this.setAttribute('class', 'children open');
				}
				else if (currentClass == 'children open') {
					this.setAttribute('class', 'children');
				}
				return false;
			}
			
			function tocEntryClick(e)
			{
				e.stopPropagation();
				return true;
			}
			
			function init()
			{
				var selectElement = document.getElementById('jumpTo');
				selectElement.addEventListener('change', jumpToChange, false);
				
				var tocButton = document.getElementById('table_of_contents');
				tocButton.addEventListener('click', toggleTOC, false);
				
				var taskTreeItem = document.getElementById('task_treeitem');
				if (taskTreeItem.getElementsByTagName('li').length > 0)
				{
					taskTreeItem.setAttribute('class', 'children');
					taskTreeItem.firstChild.setAttribute('class', 'disclosure');
				}
				
				var tocList = document.getElementById('toc');
				
				var tocEntries = tocList.getElementsByTagName('li');
				for (var i = 0; i < tocEntries.length; i++) {
					tocEntries[i].addEventListener('click', toggleTOCEntryChildren, false);
				}
				
				var tocLinks = tocList.getElementsByTagName('a');
				for (var i = 0; i < tocLinks.length; i++) {
					tocLinks[i].addEventListener('click', tocEntryClick, false);
				}
				
				if (window.name == "hideTOC") {
					toggleTOC.call(tocButton);
				}
			}
			
			window.onload = init;
			
			// If showing in Xcode, hide the TOC and Header
			if (navigator.userAgent.match(/xcode/i)) {
				document.getElementById("contents").className = "hideInXcode"
				document.getElementById("tocContainer").className = "hideInXcode"
				document.getElementById("top_header").className = "hideInXcode"
			}
			
		</script>
	</body>
</html>